<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Flappy Abby - A fun browser-based game">
    <title>Flappy Abby</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
    :root {
        --primary-color: #007bff;
        --primary-hover: #0056b3;
        --danger-color: #dc3545;
        --success-color: #28a745;
        --sky-blue: #70c5ce;
        --ground-tan: #d2b48c;
        --pipe-green: #1e7b1e;
        --pipe-dark: #145214;
        --border-radius: 10px;
        --transition-speed: 0.2s;
        --shadow-light: 0 4px 10px rgba(0,0,0,0.1);
        --shadow-medium: 0 8px 30px rgba(0,0,0,0.2);
        --shadow-heavy: 0 10px 40px rgba(0,0,0,0.3);
    }
    
    *, *::before, *::after {
        box-sizing: border-box;
    }
    
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        margin: 0;
        padding: 20px;
        overflow: hidden;
    }
    
    .screen {
        display: none;
        flex-direction: column;
        align-items: center;
        padding: 40px;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-heavy);
        text-align: center;
        max-width: 600px;
        width: 100%;
        animation: fadeIn 0.3s ease-in;
    }
    
    @keyframes fadeIn {
        from { 
            opacity: 0; 
            transform: translateY(-20px); 
        }
        to { 
            opacity: 1; 
            transform: translateY(0); 
        }
    }
    
    .screen.active {
        display: flex;
    }
    
    #game-container {
        display: none;
        position: relative;
        animation: fadeIn 0.3s ease-in;
    }
    
    #game-container.active {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    
    canvas {
        border: 4px solid #333;
        border-radius: 12px;
        background-color: var(--sky-blue);
        display: block;
        box-shadow: var(--shadow-medium);
        touch-action: none;
        cursor: pointer;
    }
    
    #score-display {
        position: absolute;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 4rem;
        font-weight: bold;
        color: white;
        text-shadow: 4px 4px 8px rgba(0,0,0,0.6);
        pointer-events: none;
        z-index: 10;
    }
    
    h1 {
        font-size: 3rem;
        margin: 0 0 15px 0;
        color: var(--primary-color);
    }
    
    h2 {
        font-size: 2.5rem;
        margin: 15px 0;
    }
    
    h3 {
        font-size: 2rem;
        margin: 15px 0;
    }
    
    p {
        margin: 15px 0;
        color: #666;
        line-height: 1.6;
        font-size: 1.1rem;
    }
    
    input {
        font-size: 1.2rem;
        padding: 15px 20px;
        border: 2px solid #ddd;
        border-radius: 8px;
        margin: 20px 0;
        width: 100%;
        max-width: 350px;
        text-align: center;
        transition: border-color var(--transition-speed);
    }
    
    input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    }
    
    input:invalid {
        border-color: var(--danger-color);
    }
    
    button {
        font-size: 1.2rem;
        padding: 15px 40px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all var(--transition-speed);
        margin: 12px 8px;
        font-weight: 600;
        box-shadow: 0 4px 10px rgba(0,123,255,0.3);
        position: relative;
        overflow: hidden;
    }
    
    button::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
    }
    
    button:hover::before {
        width: 300px;
        height: 300px;
    }
    
    button:hover {
        background-color: var(--primary-hover);
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(0,123,255,0.4);
    }
    
    button:active {
        transform: translateY(0);
    }
    
    button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }
    
    button:focus-visible {
        outline: 3px solid var(--primary-color);
        outline-offset: 2px;
    }
    
    #leaderboard-display {
        width: 100%;
        margin-top: 30px;
    }
    
    #leaderboard-list {
        text-align: left;
        padding: 0;
        list-style: none;
        max-height: 400px;
        overflow-y: auto;
    }
    
    #leaderboard-list li {
        font-size: 1.1rem;
        padding: 15px 18px;
        margin: 8px 0;
        border: 1px solid #eee;
        border-radius: 8px;
        transition: all var(--transition-speed);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    #leaderboard-list li::before {
        content: attr(data-rank);
        font-weight: bold;
        color: var(--primary-color);
        margin-right: 12px;
        min-width: 30px;
        font-size: 1.2rem;
    }
    
    #leaderboard-list li:hover {
        background-color: #f8f9fa;
        transform: translateX(5px);
        box-shadow: var(--shadow-light);
    }
    
    #leaderboard-list li.current-player {
        background-color: #fff3cd;
        font-weight: bold;
        border-color: #ffc107;
    }
    
    #leaderboard-list li.rank-1 { background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); }
    #leaderboard-list li.rank-2 { background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 100%); }
    #leaderboard-list li.rank-3 { background: linear-gradient(135deg, #cd7f32 0%, #e8a76f 100%); }
    
    .loading {
        color: #666;
        font-style: italic;
        font-size: 1.1rem;
    }
    
    .error {
        color: var(--danger-color);
        font-size: 1rem;
        padding: 12px;
        background: #f8d7da;
        border-radius: 8px;
        margin: 12px 0;
    }
    
    .success {
        color: var(--success-color);
        font-size: 1rem;
        padding: 12px;
        background: #d4edda;
        border-radius: 8px;
        margin: 12px 0;
    }
    
    .instructions {
        margin: 20px 0;
        padding: 20px;
        background: #f8f9fa;
        border-left: 5px solid var(--primary-color);
        border-radius: 8px;
        font-size: 1.05rem;
        text-align: left;
    }
    
    .instructions kbd {
        background: #333;
        color: white;
        padding: 4px 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 0.95em;
    }
    
    .high-score-badge {
        display: inline-block;
        background: var(--success-color);
        color: white;
        padding: 8px 20px;
        border-radius: 25px;
        font-size: 1rem;
        margin: 12px 0;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }
    
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid var(--primary-color);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .verified-badge {
        display: inline-block;
        background: var(--success-color);
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        margin-left: 8px;
    }
    
    @media (max-width: 768px) {
        body {
            padding: 10px;
        }
        
        .screen {
            padding: 25px;
        }
        
        h1 {
            font-size: 2.5rem;
        }
        
        h2 {
            font-size: 2rem;
        }
        
        #score-display {
            font-size: 3rem;
            top: 20px;
        }
    }
    
    @media (max-width: 480px) {
        .screen {
            padding: 20px;
        }
        
        button {
            padding: 12px 25px;
            font-size: 1rem;
        }
        
        input {
            padding: 12px 16px;
            font-size: 1rem;
        }
        
        h1 {
            font-size: 2rem;
        }
        
        #score-display {
            font-size: 2.5rem;
        }
    }
    
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }
    
    #leaderboard-list::-webkit-scrollbar {
        width: 10px;
    }
    
    #leaderboard-list::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    
    #leaderboard-list::-webkit-scrollbar-thumb {
        background: var(--primary-color);
        border-radius: 10px;
    }
    
    #leaderboard-list::-webkit-scrollbar-thumb:hover {
        background: var(--primary-hover);
    }
</style>
</head>
<body>
    <div id="start-screen" class="screen active">
        <h1>üê¶ Flappy Abby</h1>
        <p>Enter your name to start playing:</p>
        <input 
            type="text" 
            id="player-name" 
            placeholder="Your Name" 
            maxlength="15"
            autocomplete="off"
            pattern="[A-Za-z0-9\s]+"
            required
            aria-label="Player name"
        >
        <button id="start-button" aria-label="Start game">Start Game</button>
        
        <div class="instructions">
            <strong>How to Play:</strong><br>
            Press <kbd>SPACE</kbd> or click/tap to flap<br>
            Avoid the pipes and ground!
        </div>
        
        <div id="high-score-display"></div>
    </div>
    
    <div id="game-container">
        <div id="score-display" aria-live="polite" aria-atomic="true">0</div>
        <canvas id="game-canvas" width="600" height="800" aria-label="Game canvas"></canvas>
    </div>

    <div id="game-over-screen" class="screen">
        <h2>üéÆ Game Over</h2>
        <h3>Your Score: <span id="final-score">0</span></h3>
        <div id="score-message"></div>
        
        <div>
            <button id="restart-button" aria-label="Play again">Play Again</button>
            <button id="home-button" aria-label="Return to main menu">Main Menu</button>
        </div>
        
        <div id="leaderboard-display">
            <h3>üèÜ Global Leaderboard</h3>
            <div id="loading-container">
                <p id="loading-scores" class="loading">Loading scores...</p>
                <div id="loading-spinner" class="spinner" style="display: none;"></div>
            </div>
            <ol id="leaderboard-list"></ol>
        </div>
    </div>

    <script>
        'use strict';
        
        // =================================================================
        // CONFIGURATION
        // =================================================================
        const CONFIG = Object.freeze({
            supabase: {
                                url: 'https://fpwgxrtmbcmkdithgdjf.supabase.co',
                anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZwd2d4cnRtYmNta2RpdGhnZGpmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIyNzQ4MDEsImV4cCI6MjA3Nzg1MDgwMX0.lvD-1ZEpi1okfPsKEhfaILBYGPkMAZT8VJpHbIZtrNo',
                tableName: 'leaderboard',
                sessionsTable: 'game_sessions'
            },
            game: {
                gravity: 0.25,
                maxGravity: 0.5,
                gravityIncrease: 0.001,
                flapStrength: -7,
                pipeSpeed: 3,
                maxPipeSpeed: 5,
                pipeSpeedIncrease: 0.005,
                pipeGap: 200,
                minPipeGap: 160,
                pipeGapDecrease: 0.05,
                pipeWidth: 90,
                pipeInterval: 110,
                groundHeight: 70,
                playerSize: 60
            },
            canvas: {
                width: 600,
                height: 800
            },
            storage: {
                highScoreKey: 'flappyAbby_highScore',
                playerNameKey: 'flappyAbby_playerName'
            }
        });
        
        // =================================================================
        // UTILITIES
        // =================================================================
        const Utils = {
            sanitizeString(str, maxLength = 15) {
                return str
                    .trim()
                    .replace(/[^A-Za-z0-9\s]/g, '')
                    .substring(0, maxLength) || 'Anonymous';
            },
            
            generateToken() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
            },
            
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },
            
            lerp(start, end, factor) {
                return start + (end - start) * factor;
            }
        };
        
        // =================================================================
        // LOCAL STORAGE MANAGER
        // =================================================================
        const StorageManager = {
            getHighScore() {
                try {
                    return parseInt(localStorage.getItem(CONFIG.storage.highScoreKey)) || 0;
                } catch {
                    return 0;
                }
            },
            
            setHighScore(score) {
                try {
                    const currentHigh = this.getHighScore();
                    if (score > currentHigh) {
                        localStorage.setItem(CONFIG.storage.highScoreKey, score);
                        return true;
                    }
                    return false;
                } catch {
                    return false;
                }
            },
            
            getPlayerName() {
                try {
                    return localStorage.getItem(CONFIG.storage.playerNameKey) || '';
                } catch {
                    return '';
                }
            },
            
            setPlayerName(name) {
                try {
                    localStorage.setItem(CONFIG.storage.playerNameKey, name);
                } catch {
                    console.warn('Unable to save player name');
                }
            }
        };
        
        // =================================================================
        // SUPABASE MANAGER
        // =================================================================
        const SupabaseManager = {
            client: null,
            isEnabled: false,
            
            init() {
                if (CONFIG.supabase.url !== 'YOUR_SUPABASE_URL_HERE') {
                    try {
                        this.client = window.supabase.createClient(
                            CONFIG.supabase.url, 
                            CONFIG.supabase.anonKey
                        );
                        this.isEnabled = true;
                        console.log('‚úì Supabase initialized');
                    } catch (error) {
                        console.error('Supabase initialization error:', error);
                        this.isEnabled = false;
                    }
                } else {
                    console.warn('‚ö† Supabase keys not configured');
                    this.isEnabled = false;
                }
                return this.isEnabled;
            },
            
            async createGameSession(playerName) {
                if (!this.isEnabled || !this.client) return null;
                
                try {
                    const token = Utils.generateToken();
                    
                    const { data, error } = await this.client
                        .from(CONFIG.supabase.sessionsTable)
                        .insert([{
                            token: token,
                            player_name: Utils.sanitizeString(playerName),
                            started_at: new Date().toISOString()
                        }])
                        .select()
                        .single();
                    
                    if (error) throw error;
                    
                    console.log('‚úì Game session created:', token.substring(0, 8) + '...');
                    return token;
                } catch (err) {
                    console.error('Error creating game session:', err);
                    return null;
                }
            },
            
            async saveScore(name, score, token, duration) {
                if (!this.isEnabled || !this.client || score === 0 || !token) return false;
                
                try {
                    // Use the RPC function to verify and save
                    const { data, error } = await this.client
                        .rpc('verify_and_save_score', {
                            p_token: token,
                            p_name: Utils.sanitizeString(name),
                            p_score: score,
                            p_duration: duration
                        });
                    
                    if (error) {
                        console.error('Error saving score:', error);
                        return false;
                    }
                    
                    if (data) {
                        console.log('‚úì Score verified and saved successfully');
                        return true;
                    } else {
                        console.warn('‚ö† Score rejected - invalid session');
                        return false;
                    }
                } catch (err) {
                    console.error('Error saving score:', err);
                    return false;
                }
            },
            
            async fetchLeaderboard(limit = 10) {
                if (!this.isEnabled || !this.client) return null;
                
                try {
                    const { data, error } = await this.client
                        .from(CONFIG.supabase.tableName)
                        .select('name, score, verified, created_at')
                        .order('score', { ascending: false })
                        .limit(limit);
                    
                    if (error) throw error;
                    return data;
                } catch (err) {
                    console.error('Error fetching leaderboard:', err);
                    return null;
                }
            }
        };
        
        // =================================================================
        // DOM MANAGER
        // =================================================================
        const DOMManager = {
            elements: null,
            ctx: null,
            
            init() {
                this.elements = {
                    startScreen: document.getElementById('start-screen'),
                    gameContainer: document.getElementById('game-container'),
                    gameOverScreen: document.getElementById('game-over-screen'),
                    nameInput: document.getElementById('player-name'),
                    startButton: document.getElementById('start-button'),
                    restartButton: document.getElementById('restart-button'),
                    homeButton: document.getElementById('home-button'),
                    finalScoreDisplay: document.getElementById('final-score'),
                    scoreDisplay: document.getElementById('score-display'),
                    scoreMessage: document.getElementById('score-message'),
                    leaderboardList: document.getElementById('leaderboard-list'),
                    loadingScores: document.getElementById('loading-scores'),
                    loadingSpinner: document.getElementById('loading-spinner'),
                    highScoreDisplay: document.getElementById('high-score-display'),
                    canvas: document.getElementById('game-canvas')
                };
                
                this.ctx = this.elements.canvas.getContext('2d', { alpha: false });
                
                const savedName = StorageManager.getPlayerName();
                if (savedName) {
                    this.elements.nameInput.value = savedName;
                }
                
                this.updateHighScoreDisplay();
            },
            
            showScreen(screenName) {
                Object.values(this.elements).forEach(el => {
                    if (el && el.classList && el.classList.contains('screen')) {
                        el.classList.remove('active');
                    }
                });
                
                if (screenName === 'game') {
                    this.elements.gameContainer.classList.add('active');
                } else if (screenName === 'start') {
                    this.elements.startScreen.classList.add('active');
                } else if (screenName === 'gameOver') {
                    this.elements.gameOverScreen.classList.add('active');
                }
            },
            
            updateScore(score) {
                this.elements.scoreDisplay.textContent = score;
            },
            
            updateHighScoreDisplay() {
                const highScore = StorageManager.getHighScore();
                if (highScore > 0) {
                    this.elements.highScoreDisplay.innerHTML = 
                        `<div class="high-score-badge">üèÜ High Score: ${highScore}</div>`;
                }
            },
            
            showFinalScore(score) {
                this.elements.finalScoreDisplay.textContent = score;
                
                const highScore = StorageManager.getHighScore();
                const isNewHighScore = StorageManager.setHighScore(score);
                
                if (isNewHighScore) {
                    this.elements.scoreMessage.innerHTML = 
                        '<div class="success">üéâ New High Score!</div>';
                } else if (score > 0 && score === highScore) {
                    this.elements.scoreMessage.innerHTML = 
                        '<div class="success">‚ú® Matched your high score!</div>';
                } else if (score > highScore * 0.8) {
                    this.elements.scoreMessage.innerHTML = 
                        '<div>üí™ So close to your record!</div>';
                } else {
                    this.elements.scoreMessage.innerHTML = '';
                }
                
                this.updateHighScoreDisplay();
            },
            
            showLoadingLeaderboard() {
                this.elements.loadingScores.style.display = 'block';
                this.elements.loadingSpinner.style.display = 'block';
                this.elements.leaderboardList.innerHTML = '';
            },
            
            hideLoadingLeaderboard() {
                this.elements.loadingScores.style.display = 'none';
                this.elements.loadingSpinner.style.display = 'none';
            },
            
            displayLeaderboard(data, currentPlayerName, currentScore) {
                this.hideLoadingLeaderboard();
                
                if (!data || data.length === 0) {
                    this.elements.leaderboardList.innerHTML = 
                        '<li style="list-style: none; border: none;">No scores yet - be the first! üöÄ</li>';
                    return;
                }
                
                this.elements.leaderboardList.innerHTML = '';
                
                data.forEach((entry, index) => {
                    const li = document.createElement('li');
                    li.setAttribute('data-rank', `#${index + 1}`);
                    
                    if (index === 0) li.classList.add('rank-1');
                    else if (index === 1) li.classList.add('rank-2');
                    else if (index === 2) li.classList.add('rank-3');
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = entry.name;
                    
                    if (entry.verified) {
                        const verifiedBadge = document.createElement('span');
                        verifiedBadge.className = 'verified-badge';
                        verifiedBadge.textContent = '‚úì';
                        verifiedBadge.title = 'Verified score';
                        nameSpan.appendChild(verifiedBadge);
                    }
                    
                    const scoreSpan = document.createElement('span');
                    scoreSpan.textContent = entry.score;
                    scoreSpan.style.fontWeight = 'bold';
                    
                    li.appendChild(nameSpan);
                    li.appendChild(scoreSpan);
                    
                    if (entry.name === currentPlayerName && entry.score === currentScore) {
                        li.classList.add('current-player');
                        const badge = document.createElement('span');
                        badge.textContent = ' üëà';
                        li.appendChild(badge);
                    }
                    
                    this.elements.leaderboardList.appendChild(li);
                });
            },
            
            showLeaderboardError() {
                this.hideLoadingLeaderboard();
                this.elements.loadingScores.textContent = 'Unable to load leaderboard';
                this.elements.loadingScores.classList.add('error');
                this.elements.loadingScores.style.display = 'block';
            }
        };
        
        // =================================================================
        // GAME OBJECTS
        // =================================================================
        
        const Player = {
            x: 100,
            y: 250,
            width: CONFIG.game.playerSize,
            height: CONFIG.game.playerSize,
            velocityY: 0,
            rotation: 0,
            image: new Image(),
            imageLoaded: false,
            
            init() {
                this.image.src = 'abby.png';
                this.image.onload = () => {
                    this.imageLoaded = true;
                    console.log('‚úì Player image loaded');
                };
                this.image.onerror = () => {
                    console.log('‚ö† Using fallback graphics (abby.png not found)');
                };
            },
            
            reset() {
                this.y = CONFIG.canvas.height / 2;
                this.velocityY = 0;
                this.rotation = 0;
            },
            
            flap() {
                if (GameState.active) {
                    this.velocityY = CONFIG.game.flapStrength;
                }
            },
            
            update() {
                const currentGravity = Math.min(
                    CONFIG.game.gravity + (GameState.frame * CONFIG.game.gravityIncrease),
                    CONFIG.game.maxGravity
                );
                
                this.velocityY += currentGravity;
                this.y += this.velocityY;
                
                this.rotation = Math.min(Math.max(this.velocityY * 3, -30), 90);
            },
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate((this.rotation * Math.PI) / 180);
                
                if (this.imageLoaded) {
                    ctx.drawImage(
                        this.image,
                        -this.width / 2,
                        -this.height / 2,
                        this.width,
                        this.height
                    );
                } else {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.width / 4, -this.height / 6, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.width / 4, -this.height / 6, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FF6347';
                    ctx.beginPath();
                    ctx.moveTo(this.width / 2, 0);
                    ctx.lineTo(this.width / 2 + 10, -5);
                    ctx.lineTo(this.width / 2 + 10, 5);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            },
            
            getBounds() {
                return {
                    left: this.x - this.width / 2,
                    right: this.x + this.width / 2,
                    top: this.y - this.height / 2,
                    bottom: this.y + this.height / 2
                };
            },
            
            checkCollision(pipe) {
                const bounds = this.getBounds();
                const pipeRight = pipe.x + CONFIG.game.pipeWidth;
                
                if (bounds.right > pipe.x && bounds.left < pipeRight) {
                    if (bounds.top < pipe.topHeight || bounds.bottom > pipe.bottomY) {
                        return true;
                    }
                }
                return false;
            },
            
            checkBoundaryCollision() {
                const bounds = this.getBounds();
                return (
                    bounds.bottom > CONFIG.canvas.height - CONFIG.game.groundHeight ||
                    bounds.top < 0
                );
            }
        };
        
        const PipesManager = {
            list: [],
            
            add() {
                                const currentGap = Math.max(
                    CONFIG.game.pipeGap - (GameState.score * CONFIG.game.pipeGapDecrease),
                    CONFIG.game.minPipeGap
                );
                
                const minHeight = 100;
                const maxHeight = CONFIG.canvas.height - CONFIG.game.groundHeight - currentGap - 100;
                const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
                
                this.list.push({
                    x: CONFIG.canvas.width,
                    topHeight,
                    bottomY: topHeight + currentGap,
                    counted: false
                });
            },
            
            update() {
                const currentSpeed = Math.min(
                    CONFIG.game.pipeSpeed + (GameState.score * CONFIG.game.pipeSpeedIncrease),
                    CONFIG.game.maxPipeSpeed
                );
                
                if (GameState.frame % CONFIG.game.pipeInterval === 0) {
                    this.add();
                }
                
                for (let i = this.list.length - 1; i >= 0; i--) {
                    const pipe = this.list[i];
                    pipe.x -= currentSpeed;
                    
                    if (!pipe.counted && pipe.x + CONFIG.game.pipeWidth < Player.x) {
                        GameState.score++;
                        DOMManager.updateScore(GameState.score);
                        pipe.counted = true;
                    }
                    
                    if (Player.checkCollision(pipe)) {
                        GameController.endGame();
                        return;
                    }
                    
                    if (pipe.x + CONFIG.game.pipeWidth < 0) {
                        this.list.splice(i, 1);
                    }
                }
            },
            
            draw(ctx) {
                this.list.forEach(pipe => {
                    ctx.fillStyle = CONFIG.game.pipeGreen;
                    ctx.fillRect(pipe.x, 0, CONFIG.game.pipeWidth, pipe.topHeight);
                    
                    ctx.fillRect(pipe.x - 5, pipe.topHeight - 40, CONFIG.game.pipeWidth + 10, 40);
                    
                    ctx.fillRect(
                        pipe.x,
                        pipe.bottomY,
                        CONFIG.game.pipeWidth,
                        CONFIG.canvas.height - pipe.bottomY
                    );
                    
                    ctx.fillRect(pipe.x - 5, pipe.bottomY, CONFIG.game.pipeWidth + 10, 40);
                    
                    ctx.strokeStyle = CONFIG.game.pipeDark;
                    ctx.lineWidth = 3;
                    
                    ctx.strokeRect(pipe.x, 0, CONFIG.game.pipeWidth, pipe.topHeight);
                    ctx.strokeRect(pipe.x - 5, pipe.topHeight - 40, CONFIG.game.pipeWidth + 10, 40);
                    
                    ctx.strokeRect(
                        pipe.x,
                        pipe.bottomY,
                        CONFIG.game.pipeWidth,
                        CONFIG.canvas.height - pipe.bottomY
                    );
                    ctx.strokeRect(pipe.x - 5, pipe.bottomY, CONFIG.game.pipeWidth + 10, 40);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(pipe.x + 5, 0, 12, pipe.topHeight);
                    ctx.fillRect(pipe.x + 5, pipe.bottomY, 12, CONFIG.canvas.height - pipe.bottomY);
                });
            },
            
            reset() {
                this.list = [];
            }
        };
        
        const Background = {
            cloudOffset: 0,
            
            draw(ctx) {
                const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#70C5CE');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
                
                this.drawClouds(ctx);
                
                const groundY = CONFIG.canvas.height - CONFIG.game.groundHeight;
                const groundGradient = ctx.createLinearGradient(0, groundY, 0, CONFIG.canvas.height);
                groundGradient.addColorStop(0, '#DEB887');
                groundGradient.addColorStop(1, '#D2B48C');
                ctx.fillStyle = groundGradient;
                ctx.fillRect(0, groundY, CONFIG.canvas.width, CONFIG.game.groundHeight);
                
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, groundY, CONFIG.canvas.width, CONFIG.game.groundHeight);
                
                ctx.fillStyle = '#228B22';
                for (let i = 0; i < CONFIG.canvas.width; i += 15) {
                    ctx.fillRect(i, groundY - 4, 8, 4);
                }
            },
            
            drawClouds(ctx) {
                this.cloudOffset -= 0.3;
                if (this.cloudOffset < -150) this.cloudOffset = 0;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                
                const clouds = [
                    { x: 80, y: 100, size: 1.2 },
                    { x: 350, y: 150, size: 0.9 },
                    { x: 200, y: 250, size: 1.4 }
                ];
                
                clouds.forEach(cloud => {
                    const x = (cloud.x + this.cloudOffset) % (CONFIG.canvas.width + 150);
                    this.drawCloud(ctx, x, cloud.y, cloud.size);
                });
            },
            
            drawCloud(ctx, x, y, scale) {
                ctx.beginPath();
                ctx.arc(x, y, 25 * scale, 0, Math.PI * 2);
                ctx.arc(x + 30 * scale, y, 30 * scale, 0, Math.PI * 2);
                ctx.arc(x + 60 * scale, y, 25 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        };
        
        // =================================================================
        // GAME STATE
        // =================================================================
        const GameState = {
            active: false,
            score: 0,
            frame: 0,
            playerName: 'Player',
            animationId: null,
            gameToken: null,
            startTime: null,
            
            reset() {
                this.score = 0;
                this.frame = 0;
                this.active = false;
                this.gameToken = null;
                this.startTime = null;
            }
        };
        
        // =================================================================
        // GAME CONTROLLER
        // =================================================================
        const GameController = {
            init() {
                DOMManager.init();
                Player.init();
                SupabaseManager.init();
                this.setupEventListeners();
                
                console.log('üéÆ Flappy Abby initialized');
            },
            
            setupEventListeners() {
                DOMManager.elements.startButton.addEventListener('click', () => this.startGame());
                
                DOMManager.elements.nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.startGame();
                });
                
                DOMManager.elements.restartButton.addEventListener('click', () => this.startGame());
                
                DOMManager.elements.homeButton.addEventListener('click', () => this.returnToMenu());
                
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.key === ' ') {
                        e.preventDefault();
                        Player.flap();
                    }
                });
                
                DOMManager.elements.canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    Player.flap();
                });
                
                DOMManager.elements.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    Player.flap();
                }, { passive: false });
                
                DOMManager.elements.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            },
            
            async startGame() {
                const rawName = DOMManager.elements.nameInput.value.trim();
                GameState.playerName = Utils.sanitizeString(rawName);
                StorageManager.setPlayerName(GameState.playerName);
                
                GameState.reset();
                Player.reset();
                PipesManager.reset();
                
                if (SupabaseManager.isEnabled) {
                    GameState.gameToken = await SupabaseManager.createGameSession(GameState.playerName);
                    if (!GameState.gameToken) {
                        console.warn('‚ö† Failed to create game session, scores will not be saved');
                    }
                }
                
                GameState.startTime = Date.now();
                
                DOMManager.updateScore(0);
                DOMManager.showScreen('game');
                
                GameState.active = true;
                this.gameLoop();
            },
            
            gameLoop() {
                if (!GameState.active) return;
                
                const ctx = DOMManager.ctx;
                
                Background.draw(ctx);
                
                Player.update();
                PipesManager.update();
                
                if (Player.checkBoundaryCollision()) {
                    this.endGame();
                    return;
                }
                
                PipesManager.draw(ctx);
                Player.draw(ctx);
                
                GameState.frame++;
                GameState.animationId = requestAnimationFrame(() => this.gameLoop());
            },
            
            endGame() {
                GameState.active = false;
                
                if (GameState.animationId) {
                    cancelAnimationFrame(GameState.animationId);
                }
                
                DOMManager.showScreen('gameOver');
                DOMManager.showFinalScore(GameState.score);
                
                this.handleLeaderboard();
            },
            
            async handleLeaderboard() {
                if (!SupabaseManager.isEnabled) {
                    DOMManager.elements.loadingScores.textContent = 
                        'Leaderboard unavailable (Supabase not configured)';
                    return;
                }
                
                DOMManager.showLoadingLeaderboard();
                
                if (GameState.score > 0 && GameState.gameToken && GameState.startTime) {
                    const gameDuration = Date.now() - GameState.startTime;
                    
                    const saved = await SupabaseManager.saveScore(
                        GameState.playerName,
                        GameState.score,
                        GameState.gameToken,
                        gameDuration
                    );
                    
                    if (saved) {
                        console.log('‚úì Score successfully verified and saved');
                    } else {
                        console.warn('‚ö† Score could not be verified');
                        DOMManager.elements.scoreMessage.innerHTML += 
                            '<div class="error">‚ö† Score not verified - may not appear on leaderboard</div>';
                    }
                }
                
                const data = await SupabaseManager.fetchLeaderboard();
                
                if (data) {
                    DOMManager.displayLeaderboard(data, GameState.playerName, GameState.score);
                } else {
                    DOMManager.showLeaderboardError();
                }
            },
            
            returnToMenu() {
                DOMManager.showScreen('start');
                DOMManager.elements.nameInput.focus();
            }
        };
        
        // =================================================================
        // INITIALIZE GAME
        // =================================================================
        window.addEventListener('DOMContentLoaded', () => {
            GameController.init();
        });
        
    </script>
</body>
</html>